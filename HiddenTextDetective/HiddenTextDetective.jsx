/** * HiddenTextDetective.jsx * Javascript for InDesign CC, CS6, CS5.5, CS5 * Version date: 20150522 * * PURPOSE: * =========== * Show characters and invisible text in InDesign Text as HEX codes and Characters * * DISCLAIMER: * =========== * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE PRODUCER OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * * AUTHOR: * =========== * Andreas Imhof * EDV-Dienstleistungen * CH-Guemligen, Switzerland * www.aiedv.ch * CopyRight 2015 * * This is free software! * If you use this code or parts of it, be nice and mention the name of the origin developer in your sorce: Andreas Imhof, ai@aiedv.ch */	// we MUST run this in dedicated #targetengine "HiddenTextDetective" because we have persistant variables and a palette#target "InDesign"#targetengine "HiddenTextDetective"var HiddenTextDetective = function(theSplitAtParaName,options) {	var TargetApp = "InDesign",		INDminVersion = "7",		INDminVersionName = "CS5",		// run with CS5 7.x.x, CS6 8.x.x, CC 9.x.x		appVersion = app.version,		majorINDVersion = parseInt(appVersion.split(".")[0], 10);	// check InDesign and version	//alert("appVersion: " + appVersion);	if (app.name.toLowerCase().indexOf(TargetApp.toLowerCase()) < 0) {	// application name like 'Adobe InDesign'		alert("This script runs with " + TargetApp + " version " + INDminVersion + " ( " + INDminVersionName + " ) or newer.");		exit(0);	}	if (parseInt(majorINDVersion, 10) < parseInt(INDminVersion, 10)) {	// version string is like 8.0.2.413 for InDesign CS6		alert("This script needs " + TargetApp + " version " + INDminVersion + " ( " + INDminVersionName + " ) or newer.");		exit(0);	}	if (typeof(HTD_settings) == 'undefined') {		var HTD_settings = {			DEBUG: 0,					// 1 = show DEBUG alert messages, 0 = no messages			dlgw_location: []			// dialog window last position		}	}	if (typeof(HTD_wrk) == 'undefined') {		var HTD_wrk = {			dlgw: null,				// main dialog palette			isopen: false,			activeDocumentID: null,	// track active document			activeDocumentName: ""		}	}	else {		HTD_wrk.activeDocumentID = null;	// reset active document on load		HTD_wrk.activeDocumentName = "";	}	var	Product = {			applicationName: "Hidden Text Detective",			version: "01",			versionStr: "0.5",				// human readable version string			sub_version: "0",				// any bug fixes: a sub-version			versionDate: "20150520",			copyright: "\u00a9www.AiEDV.ch",			productShortcut: "htdid",		},		IDserialNumber = app.serialNumber,	// InDesign serial number - 20digits string		i, s,							// internal working counter		hDs="0123456789ABCDEF",		d2hs = function (d) {	// decimal to hex conversion			var h = hDs.substr(d&15,1);			while (d>15) { d>>=4; h=hDs.substr(d&15,1)+h;}			if (h.length < 2) h = "0" + h;			return h;		},		/**		 * Convert a Unicode string to HEX bytes		 */		UnicodeEncodeEnumerator = function (input) {			this._input = input;			this._index = -1;			this._buffer = [];		};		UnicodeEncodeEnumerator.prototype = {			current: Number.NaN,			moveNext: function() {				if (this._buffer.length > 0) {					this.current = this._buffer.shift();					return true;				}				else if (this._index >= (this._input.length - 1)) {					this.current = Number.NaN;					return false;				}				else {					var charCode = this._input.charCodeAt(++this._index);					if (charCode < 256) {						this.current = charCode;					}					else if ((charCode > 0xFF) && (charCode < 0x10000)) {	// 2 bytes							/* 							// big endian byte order							this.current = (charCode & 0xFF);	// low byte							this._buffer.push((charCode & 0xFF00) >> 8);	// hi byte							*/							// little endian byte order							this.current = (charCode & 0xFF00) >> 8;	// hi byte							this._buffer.push(charCode & 0xFF);	// low byte						}						else {	// 3 bytes (max	: 0x10FFFF							// big endian byte order							/* 							this.current = (charCode & 0xFF0000) >> 16;	// low byte							this._buffer.push((charCode & 0xFF00) >> 8);	// middle byte							this._buffer.push(charCode & 0xFF);	// hi byte							*/							// little endian byte order							this.current = (charCode & 0xFF);	// hi byte							this._buffer.push((charCode & 0xFF00) >> 8);	// middle byte							this._buffer.push((charCode & 0xFF0000) >> 16);	// low byte							}					return true;				}			}		};		var hex_string = function(characters) {		// characters is an Array of inDesign character			var count = characters.length,	// the count of characters in the array				hstr = "",				i,				chr1, chr2, chr3,				enumerator;			for (i = 0; i < count; i++) {	// walk through characters				//alert(characters[i] + " - " + list_object(characters[i]) + " - " + typeof(characters[i].charCodeAt));				if (typeof(characters[i].charCodeAt) != 'undefined') {	// is String					enumerator = new UnicodeEncodeEnumerator(characters[i]);					while (enumerator.moveNext()) {						chr1 = enumerator.current;						enumerator.moveNext();						chr2 = enumerator.current;						enumerator.moveNext();						chr3 = enumerator.current;						//alert("chr1: " + chr1 + "\nchr2: " + chr2 + "\nchr3: " + chr3);					}					if (!isNaN(chr1)) hstr += d2hs(chr1) + " ";					if (!isNaN(chr2)) hstr += d2hs(chr2) + " ";					if (!isNaN(chr3)) hstr += d2hs(chr3) + " ";				}				else {	// is SpecialCharacters Enumerator					//alert("is SpecialCharacters");					hstr += d2hs(characters[i]);				}			}			return(hstr);		},		/**		 * List an object's members		 */		list_object = function(obj, which, objname, nofuncs, maxitems) {			if (typeof(obj) == 'undefined') return('undefined');			if (typeof(obj) == null) return('null');			var str = "",				numprops = 0, n = 0,				numitems = maxitems;			if ((typeof(objname) != 'undefined') && (objname != null) && (objname != '')) str += objname + " = {\n";			for (var key in obj) numprops++;			for (var key in obj) {				if ((typeof(which) != 'undefined') && (which != null) && (which != '') && (key.toLowerCase().indexOf(which) < 0)) continue;				try {					if ( (obj[key].constructor.name == 'Function') && (typeof(nofuncs) != 'undefined') && (nofuncs != null) && (nofuncs == true) ) continue;					str += key + ":";					//alert (key + ": " + obj[key] + ": " + obj[key].constructor.name);					switch (obj[key].constructor.name) {						case 'Array':							var arr = obj[key];							str += "[";							for (var i = 0; i < arr.length; i++) {								str += (typeof(arr[i]) == 'string' ? "\"" : "") + arr[i] + (typeof(arr[i]) == 'string' ? "\"" : "");								if (i < (arr.length-1)) str += ",";							}							str += "]";							break;						case 'String':							 str += "\"" + obj[key] + "\"";							break;						case 'Point':							 str += "[" + obj[key][0] + "," + obj[key][1] + "]";							break;						case 'Function':							 str += "[" + obj[key][0] + "," + obj[key][1] + "]";							break;						case 'Number':							 str += obj[key];							 break;						default:	// object							 str += "{" + obj[key] + "}";							 break;					}				} catch(ex){					str += key + ":\"not valid in this state\"";				}				n++;				if (n < numprops) str += ",\n";				else str += "\n";				if (typeof(numitems) != 'undefined') {					numitems--;					if (numitems <= 0) break;				}			}			if ((typeof(objname) != 'undefined') && (objname != null) && (objname != '')) str += "}\n";			return(str);		},		/**		 * return number of open documents		 */		numdocs_available = function() {			try {	// must try/catch: a document could be about to closing but window is still showing				var doc = app.activeDocument;	// this breaks when a document is closing				if (app.documents.length <= 0) return(0);			} catch(ex) {				return(0);			}			return(app.documents.length);		},				/**		 * return special characters name from enumarator		 */		get_enumeratorKey = function (enumerator) {			var key;			for (key in SpecialCharacters) {				if (SpecialCharacters[key] == enumerator) return key;			}			return(undefined);		},		/**		 * reset dialog fields		 */		clear_dialogFields = function() {			HTD_wrk.dlgw.textGroup.thehex.text = "";			HTD_wrk.dlgw.textGroup.thetext.text = "";			HTD_wrk.dlgw.xmlGroup.xmltag.text = "";			HTD_wrk.dlgw.paraGroup.paraname.text = "";			HTD_wrk.dlgw.charGroup.charname.text = "";			if (HTD_settings.DEBUG > 0) HTD_wrk.dlgw.debugmess.text = "";		},		/**		 * Selection has changed: get characters at cursor position		 */		in_checkSelection = false,		checkSelection = function (e, caller) {			var i,				myEvent,				myshort,				myselection = null,				characters = null,				charactersArr = null,				text = "",				hex = "",				insertionPoints = null,				selectionStart = null,				selectionEnd = null;			if (in_checkSelection === true) return;			in_checkSelection = true;	// prevent reentrance from multiple events			myEvent = e || {eventType:'undefined'};			numDocsOpen = numdocs_available();			// set dialog texts			if (numDocsOpen <= 0) {				HTD_wrk.dlgw.mess.text = "No document is open.";				clear_dialogFields();				in_checkSelection = false;				return;			}			if (app.selection.length < 1) {				HTD_wrk.dlgw.mess.text = "Nothing selected: Set the cursor into a text frame.";				clear_dialogFields();				if (HTD_settings.DEBUG > 0) HTD_wrk.dlgw.debugmess.text = "";				in_checkSelection = false;				return;			}			//alert(app.selection[0].constructor.name + "\ncontents: " + app.selection[0].contents + "\ncharacters: " + app.selection[0].characters.length);			if (HTD_settings.DEBUG > 0) {				HTD_wrk.dlgw.debugmess.text = "selection " + app.selection[0].constructor.name + " ("  + (new Date().getTime()) + " )";			}			if ( (app.selection.length == 1) 				&& ((app.selection[0] instanceof InsertionPoint) 					|| (app.selection[0] instanceof Character) 					|| (app.selection[0] instanceof Text) 					|| (app.selection[0] instanceof TextColumn) 					|| (app.selection[0] instanceof TextStyleRange) 					|| (app.selection[0] instanceof Word) 					|| (app.selection[0] instanceof Paragraph) 					|| (app.selection[0] instanceof Cell)				   )				)	{	// the cursor must be in any text				myselection = app.selection[0];				insertionPoints = myselection.insertionPoints;			}			else {				//alert("Unsupported Selection: " + app.selection[0]);				HTD_wrk.dlgw.mess.text = "Set the cursor into a text frame.";				clear_dialogFields();				in_checkSelection = false;				return;			}			//alert(myselection.parent);			try {	// if we have a parentStory				if (myselection.parentStory.characters.count() < 1) {					HTD_wrk.dlgw.mess.text = "The cursor is in an empty text frame.";					clear_dialogFields();					in_checkSelection = false;					return;				}				HTD_wrk.dlgw.mess.text = "The cursor is in a text frame.";			}			catch (ex) {				//alert("no parentstory");			}						selectionStart = insertionPoints[0].index;			selectionEnd = selectionStart;			if (insertionPoints.count() > 1) {				selectionEnd = insertionPoints[insertionPoints.count()-1].index - 1;			}			// get text			//alert("selectionStart: " + selectionStart + "\nselectionEnd: " + selectionEnd + "\ncount: " + myselection.parentStory.characters.count());			try {				switch (myselection.parent.constructor.name) {					case "Table":						HTD_wrk.dlgw.mess.text = "Set the cursor into a cell.";						clear_dialogFields();						in_checkSelection = false;						return;						break;					case "Cell":						try {							if (selectionStart == selectionEnd) {								//alert (myselection.characters.count());								characters = [myselection.characters[0]];								if (myselection.characters.count() > 0) {									charactersArr = myselection.characters.everyItem().contents;									break;								}								HTD_wrk.dlgw.mess.text = "Select some text in the cell.";								clear_dialogFields();								in_checkSelection = false;								return;							}							else {								characters = myselection.characters;								charactersArr = characters.everyItem().contents;							}							//if (selectionStart >= myselection.characters.count()) selectionStart = myselection.characters.count() - 1;							//if (selectionEnd >= myselection.characters.count()) selectionEnd = myselection.characters.count() - 1;							break;						} catch(ex) {							alert(ex.message + " at line " + ex.line + "\nselectionStart: " + selectionStart + "\nselectionEnd: " + selectionEnd + "\nfor: " +  myselection.parent.constructor.name);							HTD_wrk.dlgw.mess.text = "Set the cursor into a text frame.";							clear_dialogFields();							in_checkSelection = false;							return;						}					default:						if (selectionStart >= myselection.parentStory.characters.count()) {							HTD_wrk.dlgw.mess.text = "The cursor is at story end.";							clear_dialogFields();							in_checkSelection = false;							return;						}						if (selectionStart >= myselection.parentStory.characters.count()) selectionStart = myselection.parentStory.characters.count() - 1;						if (selectionEnd >= myselection.parentStory.characters.count()) selectionEnd = myselection.parentStory.characters.count() - 1;						characters = myselection.parentStory.characters.itemByRange (selectionStart, selectionEnd).characters;						charactersArr = characters.everyItem().contents;						break;				}			} catch(ex) {				alert(ex.message + " at line " + ex.line + "\nselectionStart: " + selectionStart + "\nselectionEnd: " + selectionEnd + "\nfor: " +  myselection.parent.constructor.name);				HTD_wrk.dlgw.mess.text = "Set the cursor into a text frame.";				clear_dialogFields();				in_checkSelection = false;				return;			}			HTD_wrk.dlgw.mess.text = "Select start: " + selectionStart + " End: " + selectionEnd + ", in: " + myselection.parent.constructor.name + ", as: " + myselection.constructor.name;			for (i = 0; i < charactersArr.length; i++) {				//alert(i + ": " + charactersArr[i].constructor.name);				if (charactersArr[i].constructor.name == "String") {					hex += hex_string([charactersArr[i]]) + "\n";					//alert("request name for: " + charactersArr[i] + " - " + parseInt(charactersArr[i].charCodeAt(0),10));					var mycharname = textchar(charactersArr[i].charCodeAt(0));					//alert(charactersArr[i] + " - " + charactersArr[i].charCodeAt(0) + " - " + mycharname);					if ((charactersArr[i].charCodeAt(0) != 0x0D) && (charactersArr[i].charCodeAt(0) != 0x0A)) text += charactersArr[i];					if (mycharname !== undefined) {						text += " = " + mycharname;					}					text += "\n";				}				else {	// SpecialCharacters Enumarator					//alert(list_object(SpecialCharacters));					hex += "{" + hex_string([charactersArr[i]]) + "}\n";					text += "{" + charactersArr[i] + " " + get_enumeratorKey(charactersArr[i]) + " " + charactersArr[i].constructor.name + "}\n";				}			}			//alert(characters.count() + " - " + characters[0].contents);			HTD_wrk.dlgw.textGroup.thehex.text = hex;			HTD_wrk.dlgw.textGroup.thetext.text = text;			// show associatedXMLElements			try {				HTD_wrk.dlgw.xmlGroup.xmltag.text = myselection.parentStory.characters[selectionStart].associatedXMLElements[0].markupTag.name + " (id " + myselection.parentStory.characters[selectionStart].associatedXMLElements[0].markupTag.id + ")";			} catch(ex) {				HTD_wrk.dlgw.xmlGroup.xmltag.text = "";			}			// show appliedParagraphStyle			//alert(characters[0].appliedParagraphStyle.constructor.name);			if (characters[0].appliedParagraphStyle.constructor.name == "Array") HTD_wrk.dlgw.paraGroup.paraname.text = characters[0].appliedParagraphStyle[0].name + " (id " + characters[0].appliedParagraphStyle[0].id + ")";			else if (characters[0].appliedParagraphStyle) HTD_wrk.dlgw.paraGroup.paraname.text = characters[0].appliedParagraphStyle.name + " (id1 " + characters[0].appliedParagraphStyle.id + ")";				else HTD_wrk.dlgw.paraGroup.paraname.text = "";				// show appliedCharacterStyle			if (characters[0].appliedCharacterStyle.constructor.name == "Array") HTD_wrk.dlgw.charGroup.charname.text = characters[0].appliedCharacterStyle[0].name + " (id " + characters[0].appliedCharacterStyle[0].id + ")";			else if (characters[0].appliedCharacterStyle) HTD_wrk.dlgw.charGroup.charname.text = characters[0].appliedCharacterStyle.name + " (id1 " + characters[0].appliedCharacterStyle.id + ")";				else HTD_wrk.dlgw.charGroup.charname.text = "";						in_checkSelection = false;		},		/**		 * Event listeners stuff		 * To keep track of selection changes		 */		app_AFTER_SELECTION_CHANGED_hdl = null,		app_AFTER_SELECTION_CHANGED = function () {			//alert("app_AFTER_SELECTION_CHANGED: ");			if (HTD_wrk.dlgw == null) return;			checkSelection({eventType:"app.AFTER_SELECTION_CHANGED"}, "app_AFTER_SELECTION_CHANGED");		},		// event listeners used only by the dialog window		addDialogEventListeners = function() {			var isactive = false, hdl = 'undefined', l;			if (HTD_wrk.dlgw == null) return(false);			// check if this listener already is set (as we can not remove it)			for (l = 0; l < app.eventListeners.length; l++) {				//alert(list_object(app.eventListeners[l]));				if (app.eventListeners[l].name == 'HiddenTextDetective app_AFTER_SELECTION_CHANGED') {					//alert("app_AFTER_SELECTION_CHANGED is already active");					isactive = true;					break;				}			}			if (!isactive) {				app_AFTER_SELECTION_CHANGED_hdl = app.addEventListener('afterSelectionChanged', app_AFTER_SELECTION_CHANGED,false);				if (app_AFTER_SELECTION_CHANGED_hdl) app_AFTER_SELECTION_CHANGED_hdl.name = "HiddenTextDetective app_AFTER_SELECTION_CHANGED";				//alert("app_AFTER_SELECTION_CHANGED_hdl: " + app_AFTER_SELECTION_CHANGED_hdl);				//alert(list_object(app_AFTER_SELECTION_CHANGED_hdl));			}			return(true);		},		removeDialogEventListeners = function(caller) {			if (HTD_wrk.dlgw == null) return(false);						try {				var removed = app.removeEventListener(Event.AFTER_SELECTION_CHANGED, app_AFTER_SELECTION_CHANGED,false);				//alert("removed: " + removed + "\n caller: " + caller);				if (removed) app_AFTER_SELECTION_CHANGED_hdl = null;			} catch(ex) {			}			/* //DEBUG			for (var l = 0; l < app.eventListeners.length; l++) {				alert(list_object(app.eventListeners[l]));			}			*/			// all listeners should now be removed!!			return(true);		},		/**		 * SET the main dialog title		 */		set_mainDialogTitle = function() {			if (HTD_wrk.dlgw == null) return;			HTD_wrk.dlgw.text = Product.applicationName + " v" + Product.versionStr + "." + Product.sub_version + "   " + Product.copyright;		},		/****************************		 * Show the main dialog		 */		showMainDialog = function (doupdate) {			var go = 0,				windowTitle,				windowFont, fontTitle, font, fontfix, fontHelp,				bluepen,				labelSize, infoSize,				editSize,				fgColor, bgColor, bgColorDisabled,				cleanUpDialog = function() {					removeDialogEventListeners("cleanUpDialog");					app.cancelAllTasks();					//alert("cleanUpDialog DONE");				},				close_dlgw = function () {					HTD_wrk.dlgw.onClose = null;	// make sure to remove us because we are called multiple times when dialog is closing					cleanUpDialog();					go = false;					HTD_wrk.dlgw.close(0);					//HTD_wrk.dlgw = null;					HTD_wrk.isopen = false;					// and store current settings					store_settings();				};			if (HTD_wrk.isopen == true) {				HTD_wrk.dlgw.show();				return;			}			HTD_wrk.dlgw = new Window('palette', "", undefined, {resizeable:false, closeButton: true, maximizeButton:false, minimizeButton:false});			set_mainDialogTitle();			// set up some window variables			windowFont = HTD_wrk.dlgw.graphics.font;			fontTitle = ScriptUI.newFont ( windowFont.name, windowFont.name.style, 14 );			font = ScriptUI.newFont ( windowFont.name, windowFont.name.style, 11 );			//fontfix = ScriptUI.newFont ( "Courier", 'REGULAR', 11 );			fontHelp = ScriptUI.newFont ( windowFont.name, 'BOLD', 18 );			bluepen = HTD_wrk.dlgw.graphics.newPen (HTD_wrk.dlgw.graphics.PenType.SOLID_COLOR, [0,0,1,1], 1);			bgColor = HTD_wrk.dlgw.graphics.newBrush (HTD_wrk.dlgw.graphics.BrushType.SOLID_COLOR, [0.95, 0.95, 0.95, 1]);			bgColorDisabled = HTD_wrk.dlgw.graphics.newBrush (HTD_wrk.dlgw.graphics.BrushType.SOLID_COLOR, [0.95, 0.95, 0.95, 1]);			labelSize = [100,1.8*font.size];			infoSize = [305,1.8*font.size];			editSize = [105,1.8*font.size];			// set up the window			HTD_wrk.dlgw.graphics.font = font;			//HTD_wrk.dlgw.graphics.backgroundColor = bgColor;			HTD_wrk.dlgw.orientation = 'column';			if ((HTD_settings.dlgw_location !== null) && (HTD_settings.dlgw_location.length == 2)) HTD_wrk.dlgw.location = HTD_settings.dlgw_location;			HTD_wrk.dlgw.margins = [7,7,7,7];			HTD_wrk.dlgw.alignChildren = ['left','top'];			HTD_wrk.dlgw.alignment = ['left','top'];			//------------------------------			// hex and text view			HTD_wrk.dlgw.textGroup = HTD_wrk.dlgw.add('group');			HTD_wrk.dlgw.textGroup.orientation = 'row';			HTD_wrk.dlgw.textGroup.alignChildren = ['left','top'];			HTD_wrk.dlgw.textGroup.alignment = ['left','top'];			HTD_wrk.dlgw.textGroup.spacing = 1;				HTD_wrk.dlgw.textGroup.thehex = HTD_wrk.dlgw.textGroup.add('edittext', undefined, "", {multiline:true, justify:'right' /*, borderless:true*/});					HTD_wrk.dlgw.textGroup.thehex.enabled = true;					HTD_wrk.dlgw.textGroup.thehex.readonly = true;					HTD_wrk.dlgw.textGroup.thehex.justify = 'right';					HTD_wrk.dlgw.textGroup.thehex.graphics.font = font;					HTD_wrk.dlgw.textGroup.thehex.size = [100,250];				HTD_wrk.dlgw.textGroup.thetext = HTD_wrk.dlgw.textGroup.add('edittext', undefined, "", {multiline:true /*, borderless:true*/});					HTD_wrk.dlgw.textGroup.thetext.enabled = true;					HTD_wrk.dlgw.textGroup.thetext.readonly = true;					HTD_wrk.dlgw.textGroup.thetext.graphics.font = font;					HTD_wrk.dlgw.textGroup.thetext.size = [340,250];			/*******/			// associated XML tag			HTD_wrk.dlgw.xmlGroup = HTD_wrk.dlgw.add('group');			HTD_wrk.dlgw.xmlGroup.orientation = 'row';			HTD_wrk.dlgw.xmlGroup.alignChildren = ['left','top'];			HTD_wrk.dlgw.xmlGroup.alignment = ['left','top'];			HTD_wrk.dlgw.xmlGroup.spacing = 5;			HTD_wrk.dlgw.xmlGroup.margins = [0,-10,0,0];				HTD_wrk.dlgw.xmlGroup.taglabel = HTD_wrk.dlgw.xmlGroup.add('statictext', undefined, "XML Tag:");					HTD_wrk.dlgw.xmlGroup.taglabel.enabled = true;					HTD_wrk.dlgw.xmlGroup.taglabel.graphics.font = font;					HTD_wrk.dlgw.xmlGroup.taglabel.size = labelSize;					HTD_wrk.dlgw.xmlGroup.taglabel.justify = 'right';				HTD_wrk.dlgw.xmlGroup.xmltag = HTD_wrk.dlgw.xmlGroup.add('statictext', undefined, "");					HTD_wrk.dlgw.xmlGroup.xmltag.enabled = true;					HTD_wrk.dlgw.xmlGroup.xmltag.graphics.font = font;					HTD_wrk.dlgw.xmlGroup.xmltag.size = infoSize;			// associated paragraph style			HTD_wrk.dlgw.paraGroup = HTD_wrk.dlgw.add('group');			HTD_wrk.dlgw.paraGroup.orientation = 'row';			HTD_wrk.dlgw.paraGroup.alignChildren = ['left','top'];			HTD_wrk.dlgw.paraGroup.alignment = ['left','top'];			HTD_wrk.dlgw.paraGroup.spacing = 5;			HTD_wrk.dlgw.paraGroup.margins = [0,-10,0,0];				HTD_wrk.dlgw.paraGroup.paralabel = HTD_wrk.dlgw.paraGroup.add('statictext', undefined, "Para Style:");					HTD_wrk.dlgw.paraGroup.paralabel.enabled = true;					HTD_wrk.dlgw.paraGroup.paralabel.graphics.font = font;					HTD_wrk.dlgw.paraGroup.paralabel.size = labelSize;					HTD_wrk.dlgw.paraGroup.paralabel.justify = 'right';				HTD_wrk.dlgw.paraGroup.paraname = HTD_wrk.dlgw.paraGroup.add('statictext', undefined, "");					HTD_wrk.dlgw.paraGroup.paraname.enabled = true;					HTD_wrk.dlgw.paraGroup.paraname.graphics.font = font;					HTD_wrk.dlgw.paraGroup.paraname.size = infoSize;			// associated character style			HTD_wrk.dlgw.charGroup = HTD_wrk.dlgw.add('group');			HTD_wrk.dlgw.charGroup.orientation = 'row';			HTD_wrk.dlgw.charGroup.alignChildren = ['left','top'];			HTD_wrk.dlgw.charGroup.alignment = ['left','top'];			HTD_wrk.dlgw.charGroup.spacing = 5;			HTD_wrk.dlgw.charGroup.margins = [0,-10,0,0];				HTD_wrk.dlgw.charGroup.charlabel = HTD_wrk.dlgw.charGroup.add('statictext', undefined, "Char Style:");					HTD_wrk.dlgw.charGroup.charlabel.enabled = true;					HTD_wrk.dlgw.charGroup.charlabel.graphics.font = font;					HTD_wrk.dlgw.charGroup.charlabel.size = labelSize;					HTD_wrk.dlgw.charGroup.charlabel.justify = 'right';				HTD_wrk.dlgw.charGroup.charname = HTD_wrk.dlgw.charGroup.add('statictext', undefined, "");					HTD_wrk.dlgw.charGroup.charname.enabled = true;					HTD_wrk.dlgw.charGroup.charname.graphics.font = font;					HTD_wrk.dlgw.charGroup.charname.size = infoSize;			// info mesasage			HTD_wrk.dlgw.mess = HTD_wrk.dlgw.add('statictext', undefined, "message");				HTD_wrk.dlgw.mess.enabled = true;				HTD_wrk.dlgw.mess.graphics.font = font;				HTD_wrk.dlgw.mess.size = [420,30];			// debug mesasage			if (HTD_settings.DEBUG > 0) {				HTD_wrk.dlgw.debugmess = HTD_wrk.dlgw.add('statictext', undefined, "debug messages here");					HTD_wrk.dlgw.debugmess.enabled = true;					HTD_wrk.dlgw.debugmess.graphics.font = font;					HTD_wrk.dlgw.debugmess.size = [420,30];			}			// closing main palette			HTD_wrk.dlgw.onClose = close_dlgw;	// onClose is called multiple times!!!!!			// keep track of window position changes			HTD_wrk.dlgw.onMove = function(e) {				HTD_settings.dlgw_location = HTD_wrk.dlgw.location;				//alert(HTD_settings.dlgw_location);				HTD_wrk.dlgw.debugmess.text = HTD_settings.dlgw_location;			};			// add dialog event listeners			addDialogEventListeners();			// Display the dialog box.			go = HTD_wrk.dlgw.show();			HTD_wrk.isopen = true;			//alert(go);			return(go);		},		/**		 * Special character codes		 */		textchars = {},		charstext = null,		textchar = function (thechar) {			// taken from InDesignCS5SDK/source/public/includes/TextChar.h			// these are all unicode values:			textchars = {				"Null"					: 0x0000,				//			Unused			: 0x0001,				//			Unused			: 0x0002,				"BreakRunInStyle"		: 0x0003,				"FootnoteMarker"		: 0x0004,				//			Unused			: 0x0005,				//			Unused			: 0x0006,				"IndentToHere"			: 0x0007,				"RightAlignedTab"		: 0x0008,				"Tab"					: 0x0009,				"LF"					: 0x000A,				"SoftCR"				: 0x000A,	// like LF				//			Unused			: 0x000B,				//			Unused			: 0x000C,				"CR"						: 0x000D,				//			Unused			: 0x000E,				//			Unused			: 0x000F,				//			Unused			: 0x0010,				//			Unused			: 0x0011,				//			Unused			: 0x0012,				//			Unused			: 0x0013,				//			Unused			: 0x0014,				//			Unused			: 0x0015,				"Table"					: 0x0016,	// table anchor character				"TableContinued"		: 0x0017,	// table middle				//		Cancel			: 0x0018,				"PageNumber"			: 0x0018,	// Cancel,				"AutoText"				: 0x0018,	// Cancel,				//		EndOfMedium		: 0x0019,				"SectionName"			: 0x0019,	// EndOfMedium,				//		Substitute		: 0x001A,				"NonRomanSpecialGlyph"	: 0x001A,	// Substitute,				"Space"					: 0x0020,				"ExclamationMark"	: 0x0021,				"QuotationMark" 	: 0x0022,	// U+0022, QUOTATION MARK, The Unicode Standard 2.0, 7-7				"NumberSign"		: 0x0023,				"DollarSign"		: 0x0024,				"PercentSign"		: 0x0025,				"Ampersand"			: 0x0026,				"Apostrophe"	 	: 0x0027,	// U+0027, APOSTROPHE, The Unicode Standard 2.0, 7-7				"LeftParenthesis"	: 0x0028,				"RightParenthesis"	: 0x0029,				"Asterisk"			: 0x002A,				"PlusSign"			: 0x002B,				"Comma"				: 0x002C,				"HyphenMinus"		: 0x002D,				"Period"			: 0x002E,				"Solidus"			: 0x002F,				"Zero"				: 0x0030,		// used for figure space width				"Colon"				: 0x003A,				"Semicolon"			: 0x003B,				"LessThanSign"		: 0x003C,				"EqualsSign"		: 0x003D,				"GreaterThanSign"	: 0x003E,				"QuestionMark"		: 0x003F,				"CommercialAt"			: 0x0040,				"LeftSquareBracket"		: 0x005B,				"ReverseSolidus"		: 0x005C,				"RightSquareBracket"	: 0x005D,				"CircumflexAccent"		: 0x005E,				"Underscore"			: 0x005F,				"GraveAccent"			: 0x0060,				"LeftCurlyBracket"		: 0x007B,				"RightCurlyBracket"		: 0x007D,				"VerticalLine"			: 0x007C,				"Tilde"					: 0x007E,				"HardSpace"				: 0x00A0,		// non-breaking, justifying space.  See u202f				"CentSign"				: 0x00A2,				"PoundSign"				: 0x00A3,				"CurrencySign"			: 0x00A4,				"YenSign"				: 0x00A5,				"BrokenBar"				: 0x00A6,				"SectionSign"			: 0x00A7,				"Diaeresis"				: 0x00A8,				"CopyrightSign"			: 0x00A9,				"LeftDblAngQuote"		: 0x00AB,	// The Unicode Standard 2.0, 7-11				"NotSign"				: 0x00AC,				"DiscretionaryHyphen"	: 0x00AD,				"RegisteredSign"		: 0x00AE,				"Macron"				: 0x00AF,				"DegreeSign"			: 0x00B0,				"SuperscriptTwo"		: 0x00B2,				"PilchrowSign"			: 0x00B6,	// paragraph				"MiddleDot"				: 0x00B7,				"SuperscriptOne"		: 0x00B9,				"RightDblAngQuote"		: 0x00BB,	// The Unicode Standard 2.0, 7-11				"EssZed"				: 0x00DF,				"LetterYWithDiaeresis"	: 0x00FF,				"CapIwithDotAbove"		: 0x0130,				"Caron"					: 0x02C7,		// hacek				"GreekOmega"			: 0x03A9,				"GreekPi"				: 0x03C0,				// Hebrew Characters				"HebrewMaqaf"			: 0x05BE, 	// The Unicode Standard 2.0, 7-66				"HebrewGeresh"			: 0x05F3, 	// The Unicode Standard 2.0, 7-66				"HebrewGershayim"		: 0x05F4, 	// The Unicode Standard 2.0, 7-66				"HebrewSofPasuk"		: 0x05C3, 	// The Unicode Standard 2.0, 7-66				// Arabic punctuation				"ArabicComma"			: 0x060C, 	// The Unicode Standard 2.0, 7-66				"ArabicSemicolon"		: 0x061B, 	// The Unicode Standard 2.0, 7-66				"ArabicQuestionMark"	: 0x061F, 	// The Unicode Standard 2.0, 7-66				"ArabicKashida"			: 0x0640, 	// The Unicode Standard 2.0, 7-66				"ThaiSaraAa"			: 0x0e32,				"ThaiSaraAm"			: 0x0e33,				"ThaiNikhahit"			: 0x0e4d,				"FlushSpace"			: 0x2001,	// stole em quad				"EnSpace"				: 0x2002,				"EmSpace"				: 0x2003,				"ThirdSpace"			: 0x2004,				"QuarterSpace"			: 0x2005,				"SixthSpace"			: 0x2006,				"FigureSpace"			: 0x2007,				"PunctuationSpace"		: 0x2008,				"ThinSpace"				: 0x2009,				"HairSpace"				: 0x200A,				"ZeroSpaceBreak"		: 0x200B,				//			ZeroSpaceNoBreak	: 0xFEFF,				"ZeroWidthNonJoiner"	: 0x200C,				"ZeroWidthJoiner"		: 0x200D,				"LeftToRightMark"		: 0x200E,				"RightToLeftMark"		: 0x200F,				"UnicodeHyphen"	: 0x2010,				"NoBreakHyphen"	: 0x2011,				"FigureDash"	: 0x2012,				"EnDash"		: 0x2013,				"EmDash"		: 0x2014,				"HorizontalBar"	: 0x2015,				"LeftDoubleQuotationMark"			: 0x201C,	// U+201C, LEFT DOUBLE QUOTATION MARK, The Unicode Standard 2.0, 7-155				"RightDoubleQuotationMark"			: 0x201D,	// U+201D, RIGHT DOUBLE QUOTATION MARK, The Unicode Standard 2.0, 7-156				"LeftSingleQuotationMark"			: 0x2018,	// U+2018, LEFT SINGLE QUOTATION MARK, The Unicode Standard 2.0, 7-155				"RightSingleQuotationMark"			: 0x2019,	// U+2019, RIGHT SINGLE QUOTATION MARK, The Unicode Standard 2.0, 7-155				"DoubleLow9QuotationMark"			: 0x201E,	// U+201E,  DOUBLE LOW-9 QUOTATION MARK, The Unicode Standard 2.0, 7-156				"DoubleHighReversed9QuotationMark"	: 0x201F,	// U+201F,  DOUBLE HIGH-REVERSED-9 QUOTATION MARK, The Unicode Standard 2.0, 7-156				"SingleLow9QuotationMark"			: 0x201A,	// U+201A,  SINGLE LOW-9 QUOTATION MARK, The Unicode Standard 2.0, 7-155				"SingleHighReversed9QuotationMark"	: 0x201B,	// U+201B,  SINGLE HIGH-REVERSED-9 QUOTATION MARK, The Unicode Standard 2.0, 7-155				"Dagger"				: 0x2020,				"DoubleDagger"			: 0x2021,				"Bullet"				: 0x2022,				"TwoDotLeader"			: 0x2025,				"Ellipse"				: 0x2026,		// Actually, it's "ellipsis"				"Ellipsis"				: 0x2026,				"Point"					: 0x2027,				"LineSeparator"			: 0x2028,				"ParagraphSeparator"	: 0x2029,				"LeftToRightEmbedding"		: 0x202A,				"RightToLeftEmbedding"		: 0x202B,				"PopDirectionalFormatting"	: 0x202C,				"LeftToRightOverride"		: 0x202D,				"RightToLeftOverride"		: 0x202E,				"NarrowNoBreakSpace"	: 0x202F,		// non-justifying non-breaking space				"PerMileSign"			: 0x2030,				"Prime"					: 0x2032,				"DoublePrime"			: 0x2033,				"LeftSingleAngQuote"	: 0x2039,	// The Unicode Standard 2.0				"RightSingleAngQuote"	: 0x203A,	// The Unicode Standard 2.0				"MedMathSpace"			: 0x205F,	// 4/18 EM				"WordJoiner"			: 0x2060,				"InvisibleSeparator"	: 0x2063,				"WonSign"				: 0x20A9,	// korean currency				// many of these are for the faked mappings to the symbol font!				"DegreeCelsius"		: 0x2103,				"DegreeFahrenheit"	: 0x2109,				"TrademarkSign"		: 0x2122,				"OhmSymbol"			: 0x2126,				"RightArrow"		: 0x2192,				"DownArrow"			: 0x2193,				"PartialDiff"		: 0x2202,				"MathDelta"			: 0x2206,				"Product"			: 0x220F,				"Summation"			: 0x2211,				"Radical"			: 0x221A,				"Integral"			: 0x222B,				"ApproxEqual"		: 0x2248,				"NotEqual"			: 0x2260,				"LessEqual"			: 0x2264,				"GreaterEqual"		: 0x2265,				"Infinity"			: 0x221E,				"Diamond"			: 0x25CA,				"DottedCircle"		: 0x25CC, 				"WRPointedIndex"		: 0x261E,				"WDPointedIndex"		: 0x261F,				"MusicSharpSign"		: 0x266F,				"CheckmarkSign"			: 0x2713,				//CJK support				"IdeographicSpace"				: 0x3000,				"CJKStart"						: 0x3000, 	// like IdeographicSpace				"CJKPostalMarkFace"				: 0x3020,				"CJKCompatibilityEnd"			: 0x33FF,				"CJKHalfFullStart"				: 0xFF01,				"CJKHalfIdeographicFullStop"	: 0xFF61,				"CJKHalfIdeographicComma"		: 0xFF64,				"CJKHalfFullEnd"				: 0xFF9F,				//CJK symbols and punctuation				"IdeographicComma"					: 0x3001,				"IdeographicFullStop"				: 0x3002,				"IterationMark"						: 0x3005,				"LeftAngleBracket"					: 0x3008,				"RightAngleBracket"					: 0x3009,				"LeftDoubleAngleBracket"			: 0x300A,				"RightDoubleAngleBracket"			: 0x300B,				"LeftCornerBracket"					: 0x300C,				"RightCornerBracket"				: 0x300D,				"LeftWhiteCornerBracket"			: 0x300E,				"RightWhiteCornerBracket"			: 0x300F,				"LeftBlackLenticularBracket"		: 0x3010,				"RightBlackLenticularBracket"		: 0x3011,				"PostalMark"						: 0x3012,				"leftTortoiseShellBracket"			: 0x3014,				"RightTortoiseShellBracket"			: 0x3015,				"LeftWhiteLenticularBracket"		: 0x3016,				"RightWhiteLenticularBracket"		: 0x3017,				"leftWhiteTortoiseShellBracket"		: 0x3018,				"RightWhiteTortoiseShellBracket"	: 0x3019,				"LeftWhiteSquareBracket"			: 0x301A,				"RightWhiteSquareBracket"			: 0x301B,				"WaveDash"							: 0x301C,				//Japanese Kinsoku characters				"HiraganaSmallA"						: 0x3041,				"HiraganaSmallI"						: 0x3043,				"HiraganaSmallU"						: 0x3045,				"HiraganaSmallE"						: 0x3047,				"HiraganaSmallO"						: 0x3049,				"HiraganaSmallTsu"						: 0x3063,				"HiraganaSmallYa"						: 0x3083,				"HiraganaSmallYu"						: 0x3085,				"HiraganaSmallYo"						: 0x3087,				"HiraganaSmallWa"						: 0x308E,				"KatakanaHiraganaVoicedSoundMark"		: 0x309B,				"KatakanaHiraganaSemiVoicedSoundMark"	: 0x309C,				"HiraganaIterationMark"					: 0x309D,				"HiraganaVoicedIterationMark"			: 0x309E,				"KatakanaSmallA"				: 0x30A1,				"KatakanaSmallI"				: 0x30A3,				"KatakanaSmallU"				: 0x30A5,				"KatakanaSmallE"				: 0x30A7,				"KatakanaSmallO"				: 0x30A9,				"KatakanaGa"					: 0x30AC,				"KatakanaGi"					: 0x30AE,				"KatakanaGu"					: 0x30B0,				"KatakanaGe"					: 0x30B2,				"KatakanaGo"					: 0x30B4,				"KatakanaSa"					: 0x30B5,				"KatakanaZa"					: 0x30B6,				"KatakanaZi"					: 0x30B8,				"KatakanaZu"					: 0x30BA,				"KatakanaZe"					: 0x30BC,				"KatakanaZo"					: 0x30BE,				"KatakanaTa"					: 0x30BF,				"KatakanaDa"					: 0x30C0,				"KatakanaTi"					: 0x30C1,				"KatakanaDi"					: 0x30C2,				"KatakanaTu"					: 0x30C4,				"KatakanaDu"					: 0x30C5,				"KatakanaTe"					: 0x30C6,				"KatakanaDe"					: 0x30C7,				"KatakanaTo"					: 0x30C8,				"KatakanaDo"					: 0x30C9,				"KatakanaSmallTsu"				: 0x30C3,				"KatakanaHa"					: 0x30CF,				"KatakanaBa"					: 0x30D0,				"KatakanaPa"					: 0x30D1,				"KatakanaHi"					: 0x30D2,				"KatakanaBi"					: 0x30D3,				"KatakanaPi"					: 0x30D4,				"KatakanaHu"					: 0x30D5,				"KatakanaBu"					: 0x30D6,				"KatakanaPu"					: 0x30D7,				"KatakanaHe"					: 0x30D8,				"KatakanaBe"					: 0x30D9,				"KatakanaPe"					: 0x30DA,				"KatakanaHo"					: 0x30DB,				"KatakanaBo"					: 0x30DC,				"KatakanaPo"					: 0x30DD,				"KatakanaSmallYa"				: 0x30E3,				"KatakanaSmallYu"				: 0x30E5,				"KatakanaSmallYo"				: 0x30E7,				"KatakanaSmallWa"				: 0x30EE,				"KatakanaWo"					: 0x30F2,				"KatakanaVu"					: 0x30F4,				"KatakanaVa"					: 0x30F7,				"KatakanaVi"					: 0x30F8,				"KatakanaVe"					: 0x30F9,				"KatakanaVo"					: 0x30FA,				"KatakanaMiddleDot"				: 0x30FB,				"KatakanaSmallKa"				: 0x30F5,				"KatakanaSmallKe"				: 0x30F6,				"KatakanaHiraganaProlongedSoundMark"	: 0x30FC,				"KatakanaIterationMark"			: 0x30FD,				"KatakanaVoicedIterationMark"	: 0x30FE,				// ideographs				"CJKIdeographExtensionAStart"	: 0x3400,				"CJKIdeographExtensionAEnd"		: 0x4DB5,				"CJKUnifiedIdeographsStart"		: 0x4E00,				"CJKUnifiedIdeographsEnd"		: 0x9FA5,				// surrogates				"HighSurrogateStart"			: 0xD800,	// includes private use 0xDB80 - 0xDBFF				"HighSurrogateEnd"				: 0xDBFF,				"LowSurrogateStart"				: 0xDC00,				"LowSurrogateEnd"				: 0xDFFF,				"CJKCompatibilityIdeographsStart"	: 0xF900,				"CJKCompatibilityIdeographsEnd"		: 0xFA6A,				"CJKEnd"						: 0xFAFF, // this is misleading: there are non-CJK things in the range below this				// other stuff				"SymbolPi"			: 0xF636,				"ffLigature"		: 0xFB00,				"fiLigature"		: 0xFB01,				"flLigature"		: 0xFB02,				"ffiLigature"		: 0xFB03,				"fflLigature"		: 0xFB04,				//			AppleSymbol		: 0xFDFF,				// I was told that the apple symbol was FDFF, but CoolType was calling it E0F0.				// Unicode Variation Selectors				"VariationSelector1"			: 0xFE00,				"VariationSelector2"			: 0xFE01,				"VariationSelector3"			: 0xFE02,				"VariationSelector4"			: 0xFE03,				"VariationSelector5"			: 0xFE04,				"VariationSelector6"			: 0xFE05,				"VariationSelector7"			: 0xFE06,				"VariationSelector8"			: 0xFE07,				"VariationSelector9"			: 0xFE08,				"VariationSelector10"			: 0xFE09,				"VariationSelector11"			: 0xFE0A,				"VariationSelector12"			: 0xFE0B,				"VariationSelector13"			: 0xFE0C,				"VariationSelector14"			: 0xFE0D,				"VariationSelector15"			: 0xFE0E,				"VariationSelector16"			: 0xFE0F,				// Vertical forms				"VerticalTwoDotLeader"					: 0xFE30,				"VerticalEmDash"						: 0xFE31,				"VerticalEnDash"						: 0xFE32,				"VerticalLowLine"						: 0xFE33,				"VerticalWavyLowLine"					: 0xFE34,				"VerticalLeftParenthesis"				: 0xFE35,				"VerticalRIghtParenthesis"				: 0xFE36,				"VerticalLeftCurlyBracket"				: 0xFE37,				"VerticalRightCurlyBracket"				: 0xFE38,				"VerticalLeftTortoiseShell"				: 0xFE39,				"VerticalRightTortoiseShell"			: 0xFE3A,				"VerticalLeftBlackLenticularBracket"	: 0xFE3B,				"VerticalRightBlackLenticularBracket"	: 0xFE3C,				"VerticalLeftDoubleAngleBracket"		: 0xFE3D,				"VerticalRightDoubleAngleBracket"		: 0xFE3E,				"VerticalLeftAngleBracket"				: 0xFE3F,				"VerticalRightAngleBracket"				: 0xFE40,				"VerticalLeftCornerBracket"				: 0xFE41,				"VerticalRightCornerBracket"			: 0xFE42,				"VerticalLeftWhiteCornerBracket"		: 0xFE43,				"VerticalRightWhiteCornerBracket"		: 0xFE44,				"ZeroSpaceNoBreak"					: 0xFEFF,				"FullWidthExclamationMark"			: 0xFF01,				"FWAsciiBegin"						: 0xFF01,	// like FullWidthExclamationMark				"FullWidthDollarSign"				: 0xFF04,				"FullWidthPercentSign"				: 0xFF05,				"FullWidthLeftParenthesis"			: 0xFF08,				"FullWidthRightParenthesis"			: 0xFF09,				"FullWidthComma"					: 0xFF0C,				"FullWidthStop"						: 0xFF0E,				"FullWidthDigitZero"				: 0xFF10,				"FullWidthDigitNine"				: 0xFF19,				"FullWidthColon"					: 0xFF1A,				"FullWidthSemiColon"				: 0xFF1B,				"FullWidthQuestionMark"				: 0xFF1F,				"FullWidthCommercialAt"				: 0xFF20,				"FullWidthLeftSqaureBracket"		: 0xFF3B,				"FullWidthRightSqaureBracket"		: 0xFF3D,				"FullWidthLeftCurlyBracket"			: 0xFF5B,				"FullWidthRightCurlyBracket"		: 0xFF5D,				"FWAsciiEnd"						: 0xFF5F,				"HWKatakanaWo"						: 0xFF66,				"HalfWidthKatakanaBegin"			: 0xFF66,	// like HWKatakanaWo				"HalfWidthKatakanaU"				: 0xFF73,				"HalfWidthKatakanaKa"				: 0xFF76,				"HalfWidthKatakanaKi"				: 0xFF77,				"HalfWidthKatakanaKu"				: 0xFF78,				"HalfWidthKatakanaKe"				: 0xFF79,				"HalfWidthKatakanaKo"				: 0xFF7A,				"HalfWidthKatakanaSa"				: 0xFF7B,				"HalfWidthKatakanaSi"				: 0xFF7C,				"HalfWidthKatakanaSu"				: 0xFF7D,				"HalfWidthKatakanaSe"				: 0xFF7E,				"HalfWidthKatakanaSo"				: 0xFF7F,				"HalfWidthKatakanaTa"				: 0xFF80,				"HalfWidthKatakanaTi"				: 0xFF81,				"HalfWidthKatakanaTu"				: 0xFF82,				"HalfWidthKatakanaTe"				: 0xFF83,				"HalfWidthKatakanaTo"				: 0xFF84,				"HalfWidthKatakanaHa"				: 0xFF8A,				"HalfWidthKatakanaHi"				: 0xFF8B,				"HalfWidthKatakanaHu"				: 0xFF8C,				"HalfWidthKatakanaHe"				: 0xFF8D,				"HalfWidthKatakanaHo"				: 0xFF8E,				"HalfWidthKatakanaEnd"				: 0xFF9D,				"HalfWidthKatakanaVoicedMark"		: 0xFF9E,				"HalfWidthKatakanaSemiVoicedMark"	: 0xFF9F,				"FullWidthCentSign"					: 0xFFE0,				"FullWidthYenSign"					: 0xFFE5,				"HalfWidthKatakanaWa"				: 0xFF9C,				"ObjectReplacementCharacter"		: 0xFFFC,	// Placeholder in text for an otherwise unspecified object				"Inline"							: 0xFFFC,	// like ObjectReplacementCharacter				//"ReplacementCharacter"				: 0xFFFD,	// an incoming character whose value is unrepresentable in Unicode				"SpecialGlyph"						: 0xFFFD,	// like ReplacementCharacter				"ByteOrderingCharacter"				: 0xFFFE,	// either FFFE or FEFF depending on byte order (FEFF == BE, FFFE == LE) x86 is little endian in a byte stream.																// in an InDesign file x86 file little endian is default and it appears as byte sequence 0xFF 0xFE.																// If the BOM character 0xFEFF appears in the middle of a data stream, Unicode says it should be interpreted as a "zero-width non-breaking space" (inhibits line-breaking between word-glyphs).																// In Unicode 3.2, this usage is deprecated in favour of the "Word Joiner" character, U+2060.[1] This allows U+FEFF to be only used as a BOM.																// If the 16-bit units are represented in big-endian byte order, this BOM character will appear in the sequence of bytes as 0xFE followed by 0xFF.																// if the 16-bit units use little-endian order, the sequence of bytes will have 0xFF followed by 0xFE				"InvalidCharacter"					: 0xFFFF,				// private use area. Corporate grows down, user grows up.				// I guess we're corporate... The font group, apple, etc are using the private area too.				// Japanese gaiji characters use this area!! But becuase of a current bug in CoolType's				// unicode conversion this is not currenly conflicting. CoolType converts sjis F040 to E040 which				// is wrong. It should convert sjis F040 to E000. - mvogel 4/11/00				"PrivateZoneStart"			: 0xE000,				"PrivateZoneEnd"			: 0x0F8FF,				// These constants were used to represent special values in the document through Hotaka build 79				"kOBSOLETETextChar_Inline"					: 0xE000,				"kOBSOLETETextChar_SpecialGlyph"			: 0xE001,	// glyph specified by attributes				"kOBSOLETETextChar_PageNumber"				: 0xE002,		// in PM: #define CH_PAGE_NUMBER 0x18 // from memo to Microsoft.				"kOBSOLETETextChar_SectionName"				: 0xE003,				"kOBSOLETETextChar_NonRomanSpecialGlyph"	: 0xE004,	// non-Roman glyph specified by attributes				// These are used only by Find/Change, and are not stored in a document				"AnyCharacter"				: 0xE006,		// wildcard used in search and replace for any character				"AnyLetter"					: 0xE007,		// wildcard used in search and replace for any roman alphabet (a-z, A-Z)				"AnyDigit"					: 0xE008,		// wildcard used in search and replace for any roman digit (0 to 9)				"WhiteSpace"				: 0xE009,		// wildcard used in search and replace for any type of space				"AnyKanji"					: 0xE00A,		// wildcard used in search for any Japanese Kanji (Chinese-style) character				"ColumnBreak"				: 0xE00B,		// used in xml export				"PageBreak"					: 0xE00C,		// used in xml export				"FrameBoxBreak"				: 0xE00D,				"OddPageBreak"				: 0xE00E,				"EvenPageBreak"				: 0xE00F,				"AnySingleQuote"			: 0xE010,				"AnyDoubleQuote"			: 0xE011,				"PageCountVariable"			: 0xE012,				"ChapterNumberVariable"		: 0xE013,				"CreationDateVariable"		: 0xE014,				"ModificationDateVariable"	: 0xE015,				"FileNameVariable"			: 0xE016,				"OutputDateVariable"		: 0xE017,				"RunningHeaderPSVariable"	: 0xE018,				"CustomTextVariable"		: 0xE019,				"AnyVariable"				: 0xE020,				"AnyPageNumber"				: 0xE021,				"NextPageNumber"			: 0xE022,				"PreviousPageNumber"		: 0xE023,				"AnyBreak"					: 0xE024,				"CurrentPageNumber"			: 0xE025,				"CBContentsFormatted"		: 0xE026,   // formatted clipboard contents				"CBContentsUnformatted"		: 0xE027, 	// unformatted clipboard contents				"DoubleLeftQuote"			: 0xE028,	// Language dependent double left quote				"DoubleRightQuote"			: 0xE029,	// Language dependent double right quote				"SingleLeftQuote"			: 0xE02A,	// Language dependent single left quote				"SingleRightQuote"			: 0xE02B,	// Language dependent single right quote				"IndexMarker"				: 0xE02C,				"RunningHeaderCSVariable"	: 0xE02D,				"DoubleStraightQuote"		: 0xE02E,				"SingleStraightQuote"		: 0xE02F,				"MetadataCaptionVariable"	: 0xE030			};			if (charstext == null) {				charstext = {};				for (var key in textchars) {					//alert("key: " + key + ":" + textchars[key]);					charstext[textchars[key]] = key;				}				//list_object(charstext);			}			if (typeof(thechar) == "string") {				var mychar = textchars[thechar];				//alert(thechar + " = " + typeof(thechar) + " - " + mychar);				if (mychar == undefined) return undefined;				return d2hs(mychar);			}			//alert(thechar + " = " + typeof(thechar) + " - " + d2hs(thechar));			return charstext[thechar];		};	//-------------------------------	/**	 * Main entry point: Let's go	 */	var main = function() {		go = showMainDialog(true);		checkSelection({eventType:"app.AFTER_SELECTION_CHANGED"}, "main");	};	// propagate functions	this.main = main;};	// END HiddenTextDetective()// Let's kick off the HiddenTextDetectiveif (typeof(Script_instance) == 'undefined') {	//alert("defining Script_instance");	var Script_instance = null;}//Script_instance = null;	// comment for production, uncomment for development to always reload the new sourceif (Script_instance == null) Script_instance = new HiddenTextDetective();Script_instance.main();